<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Polly</name>
    </assembly>
    <members>
        <member name="T:Polly.AdvancedCircuitBreakerTResultSyntax">
            <summary>
            Fluent API for defining a Circuit Breaker <see cref="T:Polly.Policy"/>. 
            </summary>
        </member>
        <member name="M:Polly.AdvancedCircuitBreakerTResultSyntax.AdvancedCircuitBreaker``1(Polly.PolicyBuilder{``0},System.Double,System.TimeSpan,System.Int32,System.TimeSpan)">
            <summary>
            <para> Builds a <see cref="T:Polly.Policy"/> that will function like a Circuit Breaker.</para>
            <para>The circuit will break if, within any timeslice of duration <paramref name="samplingDuration"/>, the proportion of actions resulting in a handled exception or result exceeds <paramref name="failureThreshold"/>, provided also that the number of actions through the circuit in the timeslice is at least <paramref name="minimumThroughput" />. </para>
            <para>The circuit will stay broken for the <paramref name="durationOfBreak" />. Any attempt to execute this policy
            while the circuit is broken, will immediately throw a <see cref="T:Polly.CircuitBreaker.BrokenCircuitException" /> containing the exception or result
            that broke the circuit.
            </para>
            <para>If the first action after the break duration period results in a handled exception or result, the circuit will break
            again for another <paramref name="durationOfBreak" />; if no exception or handled result is encountered, the circuit will reset.
            </para>
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="failureThreshold">The failure threshold at which the circuit will break (a number between 0 and 1; eg 0.5 represents breaking if 50% or more of actions result in a handled failure).</param>
            <param name="samplingDuration">The duration of the timeslice over which failure ratios are assessed.</param>
            <param name="minimumThroughput">The minimum throughput: this many actions or more must pass through the circuit in the timeslice, for statistics to be considered significant and the circuit-breaker to come into action.</param>
            <param name="durationOfBreak">The duration the circuit will stay open before resetting.</param>
            <returns>The policy instance.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">failureThreshold;Value must be greater than zero</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">failureThreshold;Value must be less than or equal to one</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">samplingDuration;Value must be equal to or greater than the minimum resolution of the CircuitBreaker timer</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">minimumThroughput;Value must be greater than one</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">durationOfBreak;Value must be greater than zero</exception>
            <remarks>(see "Release It!" by Michael T. Nygard fi)</remarks>
        </member>
        <member name="M:Polly.AdvancedCircuitBreakerTResultSyntax.AdvancedCircuitBreaker``1(Polly.PolicyBuilder{``0},System.Double,System.TimeSpan,System.Int32,System.TimeSpan,System.Action{Polly.DelegateResult{``0},System.TimeSpan},System.Action)">
            <summary>
            <para>The circuit will break if, within any timeslice of duration <paramref name="samplingDuration"/>, the proportion of actions resulting in a handled exception or result exceeds <paramref name="failureThreshold"/>, provided also that the number of actions through the circuit in the timeslice is at least <paramref name="minimumThroughput" />. </para>
            <para>The circuit will stay broken for the <paramref name="durationOfBreak" />. Any attempt to execute this policy
            while the circuit is broken, will immediately throw a <see cref="T:Polly.CircuitBreaker.BrokenCircuitException" /> containing the exception or result
            that broke the circuit.
            </para>
            <para>If the first action after the break duration period results in a handled exception or result, the circuit will break
            again for another <paramref name="durationOfBreak" />; if no exception or handled result is encountered, the circuit will reset.
            </para>
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="failureThreshold">The failure threshold at which the circuit will break (a number between 0 and 1; eg 0.5 represents breaking if 50% or more of actions result in a handled failure.</param>
            <param name="samplingDuration">The duration of the timeslice over which failure ratios are assessed.</param>
            <param name="minimumThroughput">The minimum throughput: this many actions or more must pass through the circuit in the timeslice, for statistics to be considered significant and the circuit-breaker to come into action.</param>
            <param name="durationOfBreak">The duration the circuit will stay open before resetting.</param>
            <param name="onBreak">The action to call when the circuit transitions to an <see cref="F:Polly.CircuitBreaker.CircuitState.Open"/> state.</param>
            <param name="onReset">The action to call when the circuit resets to a <see cref="F:Polly.CircuitBreaker.CircuitState.Closed"/> state.</param>
            <returns>The policy instance.</returns>
            <remarks>(see "Release It!" by Michael T. Nygard fi)</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">failureThreshold;Value must be greater than zero</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">failureThreshold;Value must be less than or equal to one</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">samplingDuration;Value must be equal to or greater than the minimum resolution of the CircuitBreaker timer</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">minimumThroughput;Value must be greater than one</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">durationOfBreak;Value must be greater than zero</exception>
            <exception cref="T:System.ArgumentNullException">onBreak</exception>
            <exception cref="T:System.ArgumentNullException">onReset</exception>
        </member>
        <member name="M:Polly.AdvancedCircuitBreakerTResultSyntax.AdvancedCircuitBreaker``1(Polly.PolicyBuilder{``0},System.Double,System.TimeSpan,System.Int32,System.TimeSpan,System.Action{Polly.DelegateResult{``0},System.TimeSpan,Polly.Context},System.Action{Polly.Context})">
            <summary>
            <para>The circuit will break if, within any timeslice of duration <paramref name="samplingDuration"/>, the proportion of actions resulting in a handled exception or result exceeds <paramref name="failureThreshold"/>, provided also that the number of actions through the circuit in the timeslice is at least <paramref name="minimumThroughput" />. </para>
            <para>The circuit will stay broken for the <paramref name="durationOfBreak" />. Any attempt to execute this policy
            while the circuit is broken, will immediately throw a <see cref="T:Polly.CircuitBreaker.BrokenCircuitException" /> containing the exception or result
            that broke the circuit.
            </para>
            <para>If the first action after the break duration period results in a handled exception or result, the circuit will break
            again for another <paramref name="durationOfBreak" />; if no exception or handled result is encountered, the circuit will reset.
            </para>
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="failureThreshold">The failure threshold at which the circuit will break (a number between 0 and 1; eg 0.5 represents breaking if 50% or more of actions result in a handled failure.</param>
            <param name="samplingDuration">The duration of the timeslice over which failure ratios are assessed.</param>
            <param name="minimumThroughput">The minimum throughput: this many actions or more must pass through the circuit in the timeslice, for statistics to be considered significant and the circuit-breaker to come into action.</param>
            <param name="durationOfBreak">The duration the circuit will stay open before resetting.</param>
            <param name="onBreak">The action to call when the circuit transitions to an <see cref="F:Polly.CircuitBreaker.CircuitState.Open"/> state.</param>
            <param name="onReset">The action to call when the circuit resets to a <see cref="F:Polly.CircuitBreaker.CircuitState.Closed"/> state.</param>
            <returns>The policy instance.</returns>
            <remarks>(see "Release It!" by Michael T. Nygard fi)</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">failureThreshold;Value must be greater than zero</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">failureThreshold;Value must be less than or equal to one</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">samplingDuration;Value must be equal to or greater than the minimum resolution of the CircuitBreaker timer</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">minimumThroughput;Value must be greater than one</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">durationOfBreak;Value must be greater than zero</exception>
            <exception cref="T:System.ArgumentNullException">onBreak</exception>
            <exception cref="T:System.ArgumentNullException">onReset</exception>
        </member>
        <member name="M:Polly.AdvancedCircuitBreakerTResultSyntax.AdvancedCircuitBreaker``1(Polly.PolicyBuilder{``0},System.Double,System.TimeSpan,System.Int32,System.TimeSpan,System.Action{Polly.DelegateResult{``0},System.TimeSpan},System.Action,System.Action)">
            <summary>
            <para>The circuit will break if, within any timeslice of duration <paramref name="samplingDuration"/>, the proportion of actions resulting in a handled exception or result exceeds <paramref name="failureThreshold"/>, provided also that the number of actions through the circuit in the timeslice is at least <paramref name="minimumThroughput" />. </para>
            <para>The circuit will stay broken for the <paramref name="durationOfBreak" />. Any attempt to execute this policy
            while the circuit is broken, will immediately throw a <see cref="T:Polly.CircuitBreaker.BrokenCircuitException" /> containing the exception or result
            that broke the circuit.
            </para>
            <para>If the first action after the break duration period results in a handled exception or result, the circuit will break
            again for another <paramref name="durationOfBreak" />; if no exception or handled result is encountered, the circuit will reset.
            </para>
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="failureThreshold">The failure threshold at which the circuit will break (a number between 0 and 1; eg 0.5 represents breaking if 50% or more of actions result in a handled failure.</param>
            <param name="samplingDuration">The duration of the timeslice over which failure ratios are assessed.</param>
            <param name="minimumThroughput">The minimum throughput: this many actions or more must pass through the circuit in the timeslice, for statistics to be considered significant and the circuit-breaker to come into action.</param>
            <param name="durationOfBreak">The duration the circuit will stay open before resetting.</param>
            <param name="onBreak">The action to call when the circuit transitions to an <see cref="F:Polly.CircuitBreaker.CircuitState.Open"/> state.</param>
            <param name="onReset">The action to call when the circuit resets to a <see cref="F:Polly.CircuitBreaker.CircuitState.Closed"/> state.</param>
            <param name="onHalfOpen">The action to call when the circuit transitions to <see cref="F:Polly.CircuitBreaker.CircuitState.HalfOpen"/> state, ready to try action executions again. </param>
            <returns>The policy instance.</returns>
            <remarks>(see "Release It!" by Michael T. Nygard fi)</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">failureThreshold;Value must be greater than zero</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">failureThreshold;Value must be less than or equal to one</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">samplingDuration;Value must be equal to or greater than the minimum resolution of the CircuitBreaker timer</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">minimumThroughput;Value must be greater than one</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">durationOfBreak;Value must be greater than zero</exception>
            <exception cref="T:System.ArgumentNullException">onBreak</exception>
            <exception cref="T:System.ArgumentNullException">onReset</exception>
            <exception cref="T:System.ArgumentNullException">onHalfOpen</exception>
        </member>
        <member name="M:Polly.AdvancedCircuitBreakerTResultSyntax.AdvancedCircuitBreaker``1(Polly.PolicyBuilder{``0},System.Double,System.TimeSpan,System.Int32,System.TimeSpan,System.Action{Polly.DelegateResult{``0},System.TimeSpan,Polly.Context},System.Action{Polly.Context},System.Action)">
            <summary>
            <para> Builds a <see cref="T:Polly.Policy" /> that will function like a Circuit Breaker.</para>
            <para>The circuit will break if, within any timeslice of duration <paramref name="samplingDuration" />, the proportion of actions resulting in a handled exception or result exceeds <paramref name="failureThreshold" />, provided also that the number of actions through the circuit in the timeslice is at least <paramref name="minimumThroughput" />. </para>
            <para>The circuit will stay broken for the <paramref name="durationOfBreak" />. Any attempt to execute this policy
            while the circuit is broken, will immediately throw a <see cref="T:Polly.CircuitBreaker.BrokenCircuitException" /> containing the exception or result
            that broke the circuit.
            </para>
            <para>If the first action after the break duration period results in a handled exception or result, the circuit will break
            again for another <paramref name="durationOfBreak" />; if no exception or handled result is encountered, the circuit will reset.
            </para>
            </summary>
            <typeparam name="TResult">The return type of delegates which may be executed through the policy.</typeparam>
            <param name="policyBuilder">The policy builder.</param>
            <param name="failureThreshold">The failure threshold at which the circuit will break (a number between 0 and 1; eg 0.5 represents breaking if 50% or more of actions result in a handled failure.</param>
            <param name="samplingDuration">The duration of the timeslice over which failure ratios are assessed.</param>
            <param name="minimumThroughput">The minimum throughput: this many actions or more must pass through the circuit in the timeslice, for statistics to be considered significant and the circuit-breaker to come into action.</param>
            <param name="durationOfBreak">The duration the circuit will stay open before resetting.</param>
            <param name="onBreak">The action to call when the circuit transitions to an <see cref="F:Polly.CircuitBreaker.CircuitState.Open" /> state.</param>
            <param name="onReset">The action to call when the circuit resets to a <see cref="F:Polly.CircuitBreaker.CircuitState.Closed" /> state.</param>
            <param name="onHalfOpen">The action to call when the circuit transitions to <see cref="F:Polly.CircuitBreaker.CircuitState.HalfOpen" /> state, ready to try action executions again.</param>
            <returns>The policy instance.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">failureThreshold;Value must be greater than zero</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">failureThreshold;Value must be less than or equal to one</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">samplingDuration;Value must be equal to or greater than the minimum resolution of the CircuitBreaker timer</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">minimumThroughput;Value must be greater than one</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">durationOfBreak;Value must be greater than zero</exception>
            <exception cref="T:System.ArgumentNullException">onBreak</exception>
            <exception cref="T:System.ArgumentNullException">onReset</exception>
            <exception cref="T:System.ArgumentNullException">onHalfOpen</exception>
            <remarks>(see "Release It!" by Michael T. Nygard fi)</remarks>
        </member>
        <member name="T:Polly.CircuitBreakerSyntax">
            <summary>
            Fluent API for defining a Circuit Breaker <see cref="T:Polly.Policy"/>. 
            </summary>
        </member>
        <member name="M:Polly.CircuitBreakerSyntax.CircuitBreaker(Polly.PolicyBuilder,System.Int32,System.TimeSpan)">
            <summary>
            <para> Builds a <see cref="T:Polly.Policy"/> that will function like a Circuit Breaker.</para>
            <para>The circuit will break after <paramref name="exceptionsAllowedBeforeBreaking"/>
            exceptions that are handled by this policy are raised. </para>
            <para>The circuit will stay broken for the <paramref name="durationOfBreak"/>. Any attempt to execute this policy
            while the circuit is broken, will immediately throw a <see cref="T:Polly.CircuitBreaker.BrokenCircuitException"/> containing the exception 
            that broke the circuit.
            </para>
            <para>If the first action after the break duration period results in a handled exception, the circuit will break
            again for another <paramref name="durationOfBreak"/>; if no exception is thrown, the circuit will reset.
            </para>
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="exceptionsAllowedBeforeBreaking">The number of exceptions that are allowed before opening the circuit.</param>
            <param name="durationOfBreak">The duration the circuit will stay open before resetting.</param>
            <returns>The policy instance.</returns>
            <remarks>(see "Release It!" by Michael T. Nygard fi)</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">exceptionsAllowedBeforeBreaking;Value must be greater than zero.</exception>
            <exception cref="T:System.ArgumentNullException">onBreak</exception>
            <exception cref="T:System.ArgumentNullException">onReset</exception>
        </member>
        <member name="M:Polly.CircuitBreakerSyntax.CircuitBreaker(Polly.PolicyBuilder,System.Int32,System.TimeSpan,System.Action{System.Exception,System.TimeSpan},System.Action)">
            <summary>
            <para> Builds a <see cref="T:Polly.Policy"/> that will function like a Circuit Breaker.</para>
            <para>The circuit will break after <paramref name="exceptionsAllowedBeforeBreaking"/>
            exceptions that are handled by this policy are raised. </para>
            <para>The circuit will stay broken for the <paramref name="durationOfBreak"/>. Any attempt to execute this policy
            while the circuit is broken, will immediately throw a <see cref="T:Polly.CircuitBreaker.BrokenCircuitException"/> containing the exception 
            that broke the circuit.
            </para>
            <para>If the first action after the break duration period results in a handled exception, the circuit will break
            again for another <paramref name="durationOfBreak"/>; if no exception is thrown, the circuit will reset.
            </para>
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="exceptionsAllowedBeforeBreaking">The number of exceptions that are allowed before opening the circuit.</param>
            <param name="durationOfBreak">The duration the circuit will stay open before resetting.</param>
            <param name="onBreak">The action to call when the circuit transitions to an <see cref="F:Polly.CircuitBreaker.CircuitState.Open"/> state.</param>
            <param name="onReset">The action to call when the circuit resets to a <see cref="F:Polly.CircuitBreaker.CircuitState.Closed"/> state.</param>
            <returns>The policy instance.</returns>
            <remarks>(see "Release It!" by Michael T. Nygard fi)</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">exceptionsAllowedBeforeBreaking;Value must be greater than zero.</exception>
            <exception cref="T:System.ArgumentNullException">onBreak</exception>
            <exception cref="T:System.ArgumentNullException">onReset</exception>
        </member>
        <member name="M:Polly.CircuitBreakerSyntax.CircuitBreaker(Polly.PolicyBuilder,System.Int32,System.TimeSpan,System.Action{System.Exception,System.TimeSpan,Polly.Context},System.Action{Polly.Context})">
            <summary>
            <para> Builds a <see cref="T:Polly.Policy"/> that will function like a Circuit Breaker.</para>
            <para>The circuit will break after <paramref name="exceptionsAllowedBeforeBreaking"/>
            exceptions that are handled by this policy are raised. </para>
            <para>The circuit will stay broken for the <paramref name="durationOfBreak"/>. Any attempt to execute this policy
            while the circuit is broken, will immediately throw a <see cref="T:Polly.CircuitBreaker.BrokenCircuitException"/> containing the exception 
            that broke the circuit.
            </para>
            <para>If the first action after the break duration period results in a handled exception, the circuit will break
            again for another <paramref name="durationOfBreak"/>; if no exception is thrown, the circuit will reset.
            </para>
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="exceptionsAllowedBeforeBreaking">The number of exceptions that are allowed before opening the circuit.</param>
            <param name="durationOfBreak">The duration the circuit will stay open before resetting.</param>
            <param name="onBreak">The action to call when the circuit transitions to an <see cref="F:Polly.CircuitBreaker.CircuitState.Open"/> state.</param>
            <param name="onReset">The action to call when the circuit resets to a <see cref="F:Polly.CircuitBreaker.CircuitState.Closed"/> state.</param>
            <returns>The policy instance.</returns>
            <remarks>(see "Release It!" by Michael T. Nygard fi)</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">exceptionsAllowedBeforeBreaking;Value must be greater than zero.</exception>
            <exception cref="T:System.ArgumentNullException">onBreak</exception>
            <exception cref="T:System.ArgumentNullException">onReset</exception>
        </member>
        <member name="M:Polly.CircuitBreakerSyntax.CircuitBreaker(Polly.PolicyBuilder,System.Int32,System.TimeSpan,System.Action{System.Exception,System.TimeSpan},System.Action,System.Action)">
            <summary>
            <para> Builds a <see cref="T:Polly.Policy"/> that will function like a Circuit Breaker.</para>
            <para>The circuit will break after <paramref name="exceptionsAllowedBeforeBreaking"/>
            exceptions that are handled by this policy are raised. </para>
            <para>The circuit will stay broken for the <paramref name="durationOfBreak"/>. Any attempt to execute this policy
            while the circuit is broken, will immediately throw a <see cref="T:Polly.CircuitBreaker.BrokenCircuitException"/> containing the exception 
            that broke the circuit.
            </para>
            <para>If the first action after the break duration period results in a handled exception, the circuit will break
            again for another <paramref name="durationOfBreak"/>; if no exception is thrown, the circuit will reset.
            </para>
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="exceptionsAllowedBeforeBreaking">The number of exceptions that are allowed before opening the circuit.</param>
            <param name="durationOfBreak">The duration the circuit will stay open before resetting.</param>
            <param name="onBreak">The action to call when the circuit transitions to an <see cref="F:Polly.CircuitBreaker.CircuitState.Open"/> state.</param>
            <param name="onReset">The action to call when the circuit resets to a <see cref="F:Polly.CircuitBreaker.CircuitState.Closed"/> state.</param>
            <param name="onHalfOpen">The action to call when the circuit transitions to <see cref="F:Polly.CircuitBreaker.CircuitState.HalfOpen"/> state, ready to try action executions again. </param>
            <returns>The policy instance.</returns>
            <remarks>(see "Release It!" by Michael T. Nygard fi)</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">exceptionsAllowedBeforeBreaking;Value must be greater than zero.</exception>
            <exception cref="T:System.ArgumentNullException">onBreak</exception>
            <exception cref="T:System.ArgumentNullException">onReset</exception>
        </member>
        <member name="M:Polly.CircuitBreakerSyntax.CircuitBreaker(Polly.PolicyBuilder,System.Int32,System.TimeSpan,System.Action{System.Exception,System.TimeSpan,Polly.Context},System.Action{Polly.Context},System.Action)">
            <summary>
            <para> Builds a <see cref="T:Polly.Policy"/> that will function like a Circuit Breaker.</para>
            <para>The circuit will break after <paramref name="exceptionsAllowedBeforeBreaking"/>
            exceptions that are handled by this policy are raised. </para>
            <para>The circuit will stay broken for the <paramref name="durationOfBreak"/>. Any attempt to execute this policy
            while the circuit is broken, will immediately throw a <see cref="T:Polly.CircuitBreaker.BrokenCircuitException"/> containing the exception 
            that broke the circuit.
            </para>
            <para>If the first action after the break duration period results in a handled exception, the circuit will break
            again for another <paramref name="durationOfBreak"/>; if no exception is thrown, the circuit will reset.
            </para>
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="exceptionsAllowedBeforeBreaking">The number of exceptions that are allowed before opening the circuit.</param>
            <param name="durationOfBreak">The duration the circuit will stay open before resetting.</param>
            <param name="onBreak">The action to call when the circuit transitions to an <see cref="F:Polly.CircuitBreaker.CircuitState.Open"/> state.</param>
            <param name="onReset">The action to call when the circuit resets to a <see cref="F:Polly.CircuitBreaker.CircuitState.Closed"/> state.</param>
            <param name="onHalfOpen">The action to call when the circuit transitions to <see cref="F:Polly.CircuitBreaker.CircuitState.HalfOpen"/> state, ready to try action executions again. </param>
            <returns>The policy instance.</returns>
            <remarks>(see "Release It!" by Michael T. Nygard fi)</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">exceptionsAllowedBeforeBreaking;Value must be greater than zero.</exception>
            <exception cref="T:System.ArgumentNullException">onBreak</exception>
            <exception cref="T:System.ArgumentNullException">onReset</exception>
            <exception cref="T:System.ArgumentNullException">onHalfOpen</exception>
        </member>
        <member name="T:Polly.CircuitBreakerTResultSyntax">
            <summary>
            Fluent API for defining a Circuit Breaker <see cref="T:Polly.Policy"/>. 
            </summary>
        </member>
        <member name="M:Polly.CircuitBreakerTResultSyntax.CircuitBreaker``1(Polly.PolicyBuilder{``0},System.Int32,System.TimeSpan)">
            <summary>
            <para> Builds a <see cref="T:Polly.Policy"/> that will function like a Circuit Breaker.</para>
            <para>The circuit will break after <paramref name="handledEventsAllowedBeforeBreaking"/>
            exceptions or results that are handled by this policy are encountered. </para>
            <para>The circuit will stay broken for the <paramref name="durationOfBreak"/>. Any attempt to execute this policy
            while the circuit is broken, will immediately throw a <see cref="T:Polly.CircuitBreaker.BrokenCircuitException"/> containing the exception or result 
            that broke the circuit.
            </para>
            <para>If the first action after the break duration period results in a handled exception or result, the circuit will break
            again for another <paramref name="durationOfBreak"/>; if no exception or handled result is encountered, the circuit will reset.
            </para>
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="handledEventsAllowedBeforeBreaking">The number of exceptions or handled results that are allowed before opening the circuit.</param>
            <param name="durationOfBreak">The duration the circuit will stay open before resetting.</param>
            <returns>The policy instance.</returns>
            <remarks>(see "Release It!" by Michael T. Nygard fi)</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">handledEventsAllowedBeforeBreaking;Value must be greater than zero.</exception>
            <exception cref="T:System.ArgumentNullException">onBreak</exception>
            <exception cref="T:System.ArgumentNullException">onReset</exception>
        </member>
        <member name="M:Polly.CircuitBreakerTResultSyntax.CircuitBreaker``1(Polly.PolicyBuilder{``0},System.Int32,System.TimeSpan,System.Action{Polly.DelegateResult{``0},System.TimeSpan},System.Action)">
            <summary>
            <para> Builds a <see cref="T:Polly.Policy"/> that will function like a Circuit Breaker.</para>
            <para>The circuit will break after <paramref name="handledEventsAllowedBeforeBreaking"/>
            exceptions or results that are handled by this policy are encountered. </para>
            <para>The circuit will stay broken for the <paramref name="durationOfBreak"/>. Any attempt to execute this policy
            while the circuit is broken, will immediately throw a <see cref="T:Polly.CircuitBreaker.BrokenCircuitException"/> containing the exception or result 
            that broke the circuit.
            </para>
            <para>If the first action after the break duration period results in a handled exception or result, the circuit will break
            again for another <paramref name="durationOfBreak"/>; if no exception or handled result is encountered, the circuit will reset.
            </para>
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="handledEventsAllowedBeforeBreaking">The number of exceptions or handled results that are allowed before opening the circuit.</param>
            <param name="durationOfBreak">The duration the circuit will stay open before resetting.</param>
            <param name="onBreak">The action to call when the circuit transitions to an <see cref="F:Polly.CircuitBreaker.CircuitState.Open"/> state.</param>
            <param name="onReset">The action to call when the circuit resets to a <see cref="F:Polly.CircuitBreaker.CircuitState.Closed"/> state.</param>
            <returns>The policy instance.</returns>
            <remarks>(see "Release It!" by Michael T. Nygard fi)</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">handledEventsAllowedBeforeBreaking;Value must be greater than zero.</exception>
            <exception cref="T:System.ArgumentNullException">onBreak</exception>
            <exception cref="T:System.ArgumentNullException">onReset</exception>
        </member>
        <member name="M:Polly.CircuitBreakerTResultSyntax.CircuitBreaker``1(Polly.PolicyBuilder{``0},System.Int32,System.TimeSpan,System.Action{Polly.DelegateResult{``0},System.TimeSpan,Polly.Context},System.Action{Polly.Context})">
            <summary>
            <para> Builds a <see cref="T:Polly.Policy"/> that will function like a Circuit Breaker.</para>
            <para>The circuit will break after <paramref name="handledEventsAllowedBeforeBreaking"/>
            exceptions or results that are handled by this policy are encountered. </para>
            <para>The circuit will stay broken for the <paramref name="durationOfBreak"/>. Any attempt to execute this policy
            while the circuit is broken, will immediately throw a <see cref="T:Polly.CircuitBreaker.BrokenCircuitException"/> containing the exception or result 
            that broke the circuit.
            </para>
            <para>If the first action after the break duration period results in a handled exception or result, the circuit will break
            again for another <paramref name="durationOfBreak"/>; if no exception or handled result is encountered, the circuit will reset.
            </para>
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="handledEventsAllowedBeforeBreaking">The number of exceptions or handled results that are allowed before opening the circuit.</param>
            <param name="durationOfBreak">The duration the circuit will stay open before resetting.</param>
            <param name="onBreak">The action to call when the circuit transitions to an <see cref="F:Polly.CircuitBreaker.CircuitState.Open"/> state.</param>
            <param name="onReset">The action to call when the circuit resets to a <see cref="F:Polly.CircuitBreaker.CircuitState.Closed"/> state.</param>
            <returns>The policy instance.</returns>
            <remarks>(see "Release It!" by Michael T. Nygard fi)</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">handledEventsAllowedBeforeBreaking;Value must be greater than zero.</exception>
            <exception cref="T:System.ArgumentNullException">onBreak</exception>
            <exception cref="T:System.ArgumentNullException">onReset</exception>
        </member>
        <member name="M:Polly.CircuitBreakerTResultSyntax.CircuitBreaker``1(Polly.PolicyBuilder{``0},System.Int32,System.TimeSpan,System.Action{Polly.DelegateResult{``0},System.TimeSpan},System.Action,System.Action)">
            <summary>
            <para> Builds a <see cref="T:Polly.Policy"/> that will function like a Circuit Breaker.</para>
            <para>The circuit will break after <paramref name="handledEventsAllowedBeforeBreaking"/>
            exceptions or results that are handled by this policy are encountered. </para>
            <para>The circuit will stay broken for the <paramref name="durationOfBreak"/>. Any attempt to execute this policy
            while the circuit is broken, will immediately throw a <see cref="T:Polly.CircuitBreaker.BrokenCircuitException"/> containing the exception or result 
            that broke the circuit.
            </para>
            <para>If the first action after the break duration period results in a handled exception or result, the circuit will break
            again for another <paramref name="durationOfBreak"/>; if no exception or handled result is encountered, the circuit will reset.
            </para>
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="handledEventsAllowedBeforeBreaking">The number of exceptions or handled results that are allowed before opening the circuit.</param>
            <param name="durationOfBreak">The duration the circuit will stay open before resetting.</param>
            <param name="onBreak">The action to call when the circuit transitions to an <see cref="F:Polly.CircuitBreaker.CircuitState.Open"/> state.</param>
            <param name="onReset">The action to call when the circuit resets to a <see cref="F:Polly.CircuitBreaker.CircuitState.Closed"/> state.</param>
            <param name="onHalfOpen">The action to call when the circuit transitions to <see cref="F:Polly.CircuitBreaker.CircuitState.HalfOpen"/> state, ready to try action executions again. </param>
            <returns>The policy instance.</returns>
            <remarks>(see "Release It!" by Michael T. Nygard fi)</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">handledEventsAllowedBeforeBreaking;Value must be greater than zero.</exception>
            <exception cref="T:System.ArgumentNullException">onBreak</exception>
            <exception cref="T:System.ArgumentNullException">onReset</exception>
        </member>
        <member name="M:Polly.CircuitBreakerTResultSyntax.CircuitBreaker``1(Polly.PolicyBuilder{``0},System.Int32,System.TimeSpan,System.Action{Polly.DelegateResult{``0},System.TimeSpan,Polly.Context},System.Action{Polly.Context},System.Action)">
            <summary>
            <para> Builds a <see cref="T:Polly.Policy"/> that will function like a Circuit Breaker.</para>
            <para>The circuit will break after <paramref name="handledEventsAllowedBeforeBreaking"/>
            exceptions or results that are handled by this policy are encountered. </para>
            <para>The circuit will stay broken for the <paramref name="durationOfBreak"/>. Any attempt to execute this policy
            while the circuit is broken, will immediately throw a <see cref="T:Polly.CircuitBreaker.BrokenCircuitException"/> containing the exception or result 
            that broke the circuit.
            </para>
            <para>If the first action after the break duration period results in a handled exception or result, the circuit will break
            again for another <paramref name="durationOfBreak"/>; if no exception or handled result is encountered, the circuit will reset.
            </para>
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="handledEventsAllowedBeforeBreaking">The number of exceptions or handled results that are allowed before opening the circuit.</param>
            <param name="durationOfBreak">The duration the circuit will stay open before resetting.</param>
            <param name="onBreak">The action to call when the circuit transitions to an <see cref="F:Polly.CircuitBreaker.CircuitState.Open"/> state.</param>
            <param name="onReset">The action to call when the circuit resets to a <see cref="F:Polly.CircuitBreaker.CircuitState.Closed"/> state.</param>
            <param name="onHalfOpen">The action to call when the circuit transitions to <see cref="F:Polly.CircuitBreaker.CircuitState.HalfOpen"/> state, ready to try action executions again. </param>
            <returns>The policy instance.</returns>
            <remarks>(see "Release It!" by Michael T. Nygard fi)</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">handledEventsAllowedBeforeBreaking;Value must be greater than zero.</exception>
            <exception cref="T:System.ArgumentNullException">onBreak</exception>
            <exception cref="T:System.ArgumentNullException">onReset</exception>
            <exception cref="T:System.ArgumentNullException">onHalfOpen</exception>
        </member>
        <member name="T:Polly.CircuitBreaker.BrokenCircuitException">
            <summary>
            Exception thrown when a circuit is broken.
            </summary>
        </member>
        <member name="M:Polly.CircuitBreaker.BrokenCircuitException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Polly.CircuitBreaker.BrokenCircuitException"/> class.
            </summary>
        </member>
        <member name="M:Polly.CircuitBreaker.BrokenCircuitException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Polly.CircuitBreaker.BrokenCircuitException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Polly.CircuitBreaker.BrokenCircuitException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Polly.CircuitBreaker.BrokenCircuitException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="inner">The inner exception.</param>
        </member>
        <member name="M:Polly.CircuitBreaker.BrokenCircuitException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Polly.CircuitBreaker.BrokenCircuitException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Polly.CircuitBreaker.BrokenCircuitException`1">
            <summary>
            Exception thrown when a circuit is broken.
            </summary>
            <typeparam name="TResult">The TResult type being handled by the policy.</typeparam>
        </member>
        <member name="M:Polly.CircuitBreaker.BrokenCircuitException`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Polly.CircuitBreaker.BrokenCircuitException`1"/> class.
            </summary>
            <param name="result">The result which caused the circuit to break.</param>
        </member>
        <member name="M:Polly.CircuitBreaker.BrokenCircuitException`1.#ctor(System.String,`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Polly.CircuitBreaker.BrokenCircuitException`1"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="result">The result which caused the circuit to break.</param>
        </member>
        <member name="P:Polly.CircuitBreaker.BrokenCircuitException`1.Result">
            <summary>
            The result value which was considered a handled fault, by the policy.
            </summary>
        </member>
        <member name="M:Polly.CircuitBreaker.BrokenCircuitException`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Polly.CircuitBreaker.BrokenCircuitException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Polly.CircuitBreaker.CircuitBreakerPolicy">
            <summary>
            A circuit-breaker policy that can be applied to delegates.
            </summary>
        </member>
        <member name="P:Polly.CircuitBreaker.CircuitBreakerPolicy.CircuitState">
            <summary>
            Gets the state of the underlying circuit.
            </summary>
        </member>
        <member name="P:Polly.CircuitBreaker.CircuitBreakerPolicy.LastException">
            <summary>
            Gets the last exception handled by the circuit-breaker.
            </summary>
        </member>
        <member name="M:Polly.CircuitBreaker.CircuitBreakerPolicy.Isolate">
            <summary>
            Isolates (opens) the circuit manually, and holds it in this state until a call to <see cref="M:Polly.CircuitBreaker.CircuitBreakerPolicy.Reset"/> is made.
            </summary>
        </member>
        <member name="M:Polly.CircuitBreaker.CircuitBreakerPolicy.Reset">
            <summary>
            Closes the circuit, and resets any statistics controlling automated circuit-breaking.
            </summary>
        </member>
        <member name="T:Polly.CircuitBreaker.CircuitBreakerPolicy`1">
            <summary>
            A circuit-breaker policy that can be applied to delegates returning a value of type <typeparam name="TResult"/>.
            </summary>
        </member>
        <member name="P:Polly.CircuitBreaker.CircuitBreakerPolicy`1.CircuitState">
            <summary>
            Gets the state of the underlying circuit.
            </summary>
        </member>
        <member name="P:Polly.CircuitBreaker.CircuitBreakerPolicy`1.LastException">
            <summary>
            Gets the last exception handled by the circuit-breaker.
            </summary>
        </member>
        <member name="P:Polly.CircuitBreaker.CircuitBreakerPolicy`1.LastHandledResult">
            <summary>
            Gets the last result returned from a user delegate which the circuit-breaker handled.
            </summary>
        </member>
        <member name="M:Polly.CircuitBreaker.CircuitBreakerPolicy`1.Isolate">
            <summary>
            Isolates (opens) the circuit manually, and holds it in this state until a call to <see cref="M:Polly.CircuitBreaker.CircuitBreakerPolicy`1.Reset"/> is made.
            </summary>
        </member>
        <member name="M:Polly.CircuitBreaker.CircuitBreakerPolicy`1.Reset">
            <summary>
            Closes the circuit, and resets any statistics controlling automated circuit-breaking.
            </summary>
        </member>
        <member name="T:Polly.CircuitBreaker.CircuitState">
            <summary>
            Describes the possible states the circuit of a CircuitBreaker may be in.
            </summary>
        </member>
        <member name="F:Polly.CircuitBreaker.CircuitState.Closed">
            <summary>
            Closed - When the circuit is closed.  Execution of actions is allowed.
            </summary>
        </member>
        <member name="F:Polly.CircuitBreaker.CircuitState.Open">
            <summary>
            Open - When the automated controller has opened the circuit (typically due to some failure threshold being exceeded by recent actions). Execution of actions is blocked.
            </summary>
        </member>
        <member name="F:Polly.CircuitBreaker.CircuitState.HalfOpen">
            <summary>
            Half-open - When the circuit is half-open, it is recovering from an open state.  The duration of break of the preceding open state has typically passed.  In the half-open state, actions may be executed, but the results of these actions may be treated with criteria different to normal operation, to decide if the circuit has recovered sufficiently to be placed back in to the closed state, or if continuing failures mean the circuit should revert to open perhaps more quickly than in normal operation.
            </summary>
        </member>
        <member name="F:Polly.CircuitBreaker.CircuitState.Isolated">
            <summary>
            Isolated - When the circuit has been placed into a fixed open state by a call to <see cref="M:Polly.CircuitBreaker.CircuitBreakerPolicy.Isolate"/>.  This isolates the circuit manually, blocking execution of all actions until a call to <see cref="M:Polly.CircuitBreaker.CircuitBreakerPolicy.Reset"/> is made.
            </summary>
        </member>
        <member name="T:Polly.CircuitBreaker.IsolatedCircuitException">
            <summary>
            Exception thrown when a circuit is isolated (held open) by manual override.
            </summary>
        </member>
        <member name="M:Polly.CircuitBreaker.IsolatedCircuitException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Polly.CircuitBreaker.IsolatedCircuitException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Polly.CircuitBreaker.IsolatedCircuitException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Polly.CircuitBreaker.IsolatedCircuitException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Polly.Context">
            <summary>
            A readonly dictionary of string key / object value pairs
            </summary>
        </member>
        <member name="T:Polly.ContextualPolicy">
            <summary>
            Transient exception handling policies that can be applied to delegates.
            These policies can be called with arbitrary context data.
            </summary>
        </member>
        <member name="M:Polly.ContextualPolicy.Execute(System.Action,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Executes the specified action within the policy.
            </summary>
            <param name="action">The action to perform.</param>
            <param name="contextData">Arbitrary data that is passed to the exception policy.</param>
            <exception cref="T:System.ArgumentNullException">contextData</exception>
        </member>
        <member name="M:Polly.ContextualPolicy.ExecuteAndCapture(System.Action,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Executes the specified action within the policy and returns the captured result.
            </summary>
            <param name="action">The action to perform.</param>
            <param name="contextData">Arbitrary data that is passed to the exception policy.</param>
            <exception cref="T:System.ArgumentNullException">contextData</exception>
            <returns>The captured result</returns>
        </member>
        <member name="M:Polly.ContextualPolicy.Execute``1(System.Func{``0},System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Executes the specified action within the policy and returns the result.
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="action">The action to perform.</param>
            <param name="contextData">Arbitrary data that is passed to the exception policy.</param>
            <exception cref="T:System.ArgumentNullException">contextData</exception>
            <returns>
            The value returned by the action
            </returns>
            <exception cref="T:System.ArgumentNullException">contextData</exception>
        </member>
        <member name="M:Polly.ContextualPolicy.ExecuteAndCapture``1(System.Func{``0},System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Executes the specified action within the policy and returns the captured result.
            </summary>
            <param name="action">The action to perform.</param>
            <param name="contextData">Arbitrary data that is passed to the exception policy.</param>
            <exception cref="T:System.ArgumentNullException">contextData</exception>
            <returns>The captured result</returns>
        </member>
        <member name="T:Polly.ContextualPolicy`1">
            <summary>
            Transient fault handling policies that can be applied to delegates returning results of type <typeparam name="TResult"/>
            These policies can be called with arbitrary context data.
            </summary>
        </member>
        <member name="M:Polly.ContextualPolicy`1.Execute(System.Func{`0},System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Executes the specified action within the policy and returns the result.
            </summary>
            <param name="action">The action to perform.</param>
            <param name="contextData">Arbitrary data that is passed to the exception policy.</param>
            <exception cref="T:System.ArgumentNullException">contextData</exception>
            <returns>
            The value returned by the action
            </returns>
            <exception cref="T:System.ArgumentNullException">contextData</exception>
        </member>
        <member name="M:Polly.ContextualPolicy`1.ExecuteAndCapture(System.Func{`0},System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Executes the specified action within the policy and returns the captured result.
            </summary>
            <param name="action">The action to perform.</param>
            <param name="contextData">Arbitrary data that is passed to the exception policy.</param>
            <exception cref="T:System.ArgumentNullException">contextData</exception>
            <returns>The captured result</returns>
        </member>
        <member name="T:Polly.DelegateResult`1">
            <summary>
            The captured outcome of executing an individual Func&lt;TResult&gt;
            </summary>
        </member>
        <member name="P:Polly.DelegateResult`1.Result">
            <summary>
            The result of executing the delegate. Will be default(TResult) if an exception was thrown.
            </summary>
        </member>
        <member name="P:Polly.DelegateResult`1.Exception">
            <summary>
            Any exception thrown while executing the delegate. Will be null if policy executed without exception.
            </summary>
        </member>
        <member name="T:Polly.Policy">
            <summary>
            Transient exception handling policies that can
            be applied to delegates
            </summary>
        </member>
        <member name="M:Polly.Policy.Execute(System.Action)">
            <summary>
            Executes the specified action within the policy.
            </summary>
            <param name="action">The action to perform.</param>
        </member>
        <member name="M:Polly.Policy.Execute(System.Action,Polly.Context)">
            <summary>
            Executes the specified action within the policy.
            </summary>
            <param name="action">The action to perform.</param>
            <param name="context">Arbitrary data that is passed to the exception policy.</param>
        </member>
        <member name="M:Polly.Policy.ExecuteAndCapture(System.Action)">
            <summary>
            Executes the specified action within the policy and returns the captured result
            </summary>
            <param name="action">The action to perform.</param>
            <returns>The captured result</returns>
        </member>
        <member name="M:Polly.Policy.ExecuteAndCapture(System.Action,Polly.Context)">
            <summary>
            Executes the specified action within the policy and returns the captured result
            </summary>
            <param name="action">The action to perform.</param>
            <param name="context">Arbitrary data that is passed to the exception policy.</param>
            <returns>The captured result</returns>
        </member>
        <member name="M:Polly.Policy.Execute``1(System.Func{``0},Polly.Context)">
            <summary>
            Executes the specified action within the policy and returns the result.
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="action">The action to perform.</param>
            <param name="context">Arbitrary data that is passed to the exception policy.</param>
            <returns>The value returned by the action</returns>
        </member>
        <member name="M:Polly.Policy.Execute``1(System.Func{``0})">
            <summary>
            Executes the specified action within the policy and returns the Result.
            </summary>
            <typeparam name="TResult">The type of the Result.</typeparam>
            <param name="action">The action to perform.</param>
            <returns>The value returned by the action</returns>
        </member>
        <member name="M:Polly.Policy.ExecuteAndCapture``1(System.Func{``0})">
            <summary>
            Executes the specified action within the policy and returns the captured result
            </summary>
            <param name="action">The action to perform.</param>
            <returns>The captured result</returns>
        </member>
        <member name="M:Polly.Policy.ExecuteAndCapture``1(System.Func{``0},Polly.Context)">
            <summary>
            Executes the specified action within the policy and returns the captured result.
            </summary>
            <param name="action">The action to perform.</param>
            <param name="context">Arbitrary data that is passed to the exception policy.</param>
            <returns>The captured result</returns>
        </member>
        <member name="M:Polly.Policy.Handle``1">
            <summary>
            Specifies the type of exception that this policy can handle.
            </summary>
            <typeparam name="TException">The type of the exception to handle.</typeparam>
            <returns>The PolicyBuilder instance.</returns>
        </member>
        <member name="M:Polly.Policy.Handle``1(System.Func{``0,System.Boolean})">
            <summary>
            Specifies the type of exception that this policy can handle with additional filters on this exception type.
            </summary>
            <typeparam name="TException">The type of the exception.</typeparam>
            <param name="exceptionPredicate">The exception predicate to filter the type of exception this policy can handle.</param>
            <returns>The PolicyBuilder instance.</returns>
        </member>
        <member name="M:Polly.Policy.HandleResult``1(System.Func{``0,System.Boolean})">
            <summary>
            Specifies the type of return result that this policy can handle with additional filters on the result.
            </summary>
            <typeparam name="TResult">The type of return values this policy will handle.</typeparam>
            <param name="resultPredicate">The predicate to filter results this policy will handle.</param>
            <returns>The PolicyBuilder instance.</returns>
        </member>
        <member name="M:Polly.Policy.HandleResult``1(``0)">
            <summary>
            Specifies the type of return result that this policy can handle, and a result value which the policy will handle.
            </summary>
            <typeparam name="TResult">The type of return values this policy will handle.</typeparam>
            <param name="result">The TResult value this policy will handle.</param>
            <remarks>This policy filter matches the <paramref name="result"/> value returned using .Equals(), ideally suited for value types such as int and enum.  To match characteristics of class return types, consider the overload taking a result predicate.</remarks>
            <returns>The PolicyBuilder instance.</returns>
        </member>
        <member name="T:Polly.Policy`1">
            <summary>
            Transient fault handling policies that can be applied to delegates returning results of type <typeparam name="TResult"/>
            </summary>
        </member>
        <member name="M:Polly.Policy`1.Execute(System.Func{`0},Polly.Context)">
            <summary>
            Executes the specified action within the policy and returns the result.
            </summary>
            <param name="action">The action to perform.</param>
            <param name="context">Arbitrary data that is passed to the exception policy.</param>
            <returns>The value returned by the action</returns>
        </member>
        <member name="M:Polly.Policy`1.Execute(System.Func{`0})">
            <summary>
            Executes the specified action within the policy and returns the Result.
            </summary>
            <param name="action">The action to perform.</param>
            <returns>The value returned by the action</returns>
        </member>
        <member name="M:Polly.Policy`1.ExecuteAndCapture(System.Func{`0})">
            <summary>
            Executes the specified action within the policy and returns the captured result
            </summary>
            <param name="action">The action to perform.</param>
            <returns>The captured result</returns>
        </member>
        <member name="M:Polly.Policy`1.ExecuteAndCapture(System.Func{`0},Polly.Context)">
            <summary>
            Executes the specified action within the policy and returns the captured result.
            </summary>
            <param name="action">The action to perform.</param>
            <param name="context">Arbitrary data that is passed to the exception policy.</param>
            <returns>The captured result</returns>
        </member>
        <member name="M:Polly.Policy`1.Handle``1">
            <summary>
            Specifies the type of exception that this policy can handle.
            </summary>
            <typeparam name="TException">The type of the exception to handle.</typeparam>
            <returns>The PolicyBuilder instance.</returns>
        </member>
        <member name="M:Polly.Policy`1.Handle``1(System.Func{``0,System.Boolean})">
            <summary>
            Specifies the type of exception that this policy can handle with additional filters on this exception type.
            </summary>
            <typeparam name="TException">The type of the exception.</typeparam>
            <param name="exceptionPredicate">The exception predicate to filter the type of exception this policy can handle.</param>
            <returns>The PolicyBuilder instance.</returns>
        </member>
        <member name="M:Polly.Policy`1.HandleResult(System.Func{`0,System.Boolean})">
            <summary>
            Specifies a filter on the return result values that this strongly-typed generic policy will handle.
            </summary>
            <param name="resultPredicate">The predicate to filter the results this policy will handle.</param>
            <returns>The PolicyBuilder instance.</returns>
        </member>
        <member name="M:Polly.Policy`1.HandleResult(`0)">
            <summary>
            Specifies a return result value which the strongly-typed generic policy will handle.
            </summary>
            <param name="result">The TResult value this policy will handle.</param>
            <remarks>This policy filter matches the <paramref name="result"/> value returned using .Equals(), ideally suited for value types such as int and enum.  To match characteristics of class return types, consider the overload taking a result predicate.</remarks>
            <returns>The PolicyBuilder instance.</returns>
        </member>
        <member name="T:Polly.PolicyBuilder">
            <summary>
            Builder class that holds the list of current exception predicates.
            </summary>
        </member>
        <member name="M:Polly.PolicyBuilder.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="M:Polly.PolicyBuilder.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Polly.PolicyBuilder.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="M:Polly.PolicyBuilder.GetType">
            <summary>
            Gets the <see cref="T:System.Type" /> of the current instance.
            </summary>
            <returns>
            The <see cref="T:System.Type" /> instance that represents the exact runtime type of the current instance.
            </returns>
        </member>
        <member name="M:Polly.PolicyBuilder.Or``1">
            <summary>
            Specifies the type of exception that this policy can handle.
            </summary>
            <typeparam name="TException">The type of the exception to handle.</typeparam>
            <returns>The PolicyBuilder instance.</returns>
        </member>
        <member name="M:Polly.PolicyBuilder.Or``1(System.Func{``0,System.Boolean})">
            <summary>
            Specifies the type of exception that this policy can handle with additional filters on this exception type.
            </summary>
            <typeparam name="TException">The type of the exception.</typeparam>
            <param name="exceptionPredicate">The exception predicate to filter the type of exception this policy can handle.</param>
            <returns>The PolicyBuilder instance.</returns>
        </member>
        <member name="M:Polly.PolicyBuilder.OrResult``1(System.Func{``0,System.Boolean})">
            <summary>
            Specifies the type of result that this policy can handle with additional filters on the result.
            </summary>
            <typeparam name="TResult">The type of return values this policy will handle.</typeparam>
            <param name="resultPredicate">The predicate to filter the results this policy will handle.</param>
            <returns>The PolicyBuilder instance.</returns>
        </member>
        <member name="M:Polly.PolicyBuilder.OrResult``1(``0)">
            <summary>
            Specifies a result value which the policy will handle.
            </summary>
            <typeparam name="TResult">The type of return values this policy will handle.</typeparam>
            <param name="result">The TResult value this policy will handle.</param>
            <remarks>This policy filter matches the <paramref name="result"/> value returned using .Equals(), ideally suited for value types such as int and enum.  To match characteristics of class return types, consider the overload taking a result predicate.</remarks>
            <returns>The PolicyBuilder instance.</returns>
        </member>
        <member name="T:Polly.PolicyBuilder`1">
            <summary>
            Builder class that holds the list of current execution predicates filtering TResult result values.
            </summary>
        </member>
        <member name="M:Polly.PolicyBuilder`1.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="M:Polly.PolicyBuilder`1.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Polly.PolicyBuilder`1.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="M:Polly.PolicyBuilder`1.GetType">
            <summary>
            Gets the <see cref="T:System.Type" /> of the current instance.
            </summary>
            <returns>
            The <see cref="T:System.Type" /> instance that represents the exact runtime type of the current instance.
            </returns>
        </member>
        <member name="M:Polly.PolicyBuilder`1.OrResult(System.Func{`0,System.Boolean})">
            <summary>
            Specifies the type of result that this policy can handle with additional filters on the result.
            </summary>
            <param name="resultPredicate">The predicate to filter the results this policy will handle.</param>
            <returns>The PolicyBuilder instance.</returns>
        </member>
        <member name="M:Polly.PolicyBuilder`1.OrResult(`0)">
            <summary>
            Specifies a result value which the policy will handle.
            </summary>
            <param name="result">The TResult value this policy will handle.</param>
            <remarks>This policy filter matches the <paramref name="result"/> value returned using .Equals(), ideally suited for value types such as int and enum.  To match characteristics of class return types, consider the overload taking a result predicate.</remarks>
            <returns>The PolicyBuilder instance.</returns>
        </member>
        <member name="M:Polly.PolicyBuilder`1.Or``1">
            <summary>
            Specifies the type of exception that this policy can handle.
            </summary>
            <typeparam name="TException">The type of the exception to handle.</typeparam>
            <returns>The PolicyBuilder instance.</returns>
        </member>
        <member name="M:Polly.PolicyBuilder`1.Or``1(System.Func{``0,System.Boolean})">
            <summary>
            Specifies the type of exception that this policy can handle with additional filters on this exception type.
            </summary>
            <typeparam name="TException">The type of the exception.</typeparam>
            <param name="exceptionPredicate">The exception predicate to filter the type of exception this policy can handle.</param>
            <returns>The PolicyBuilder instance.</returns>
        </member>
        <member name="T:Polly.PolicyResult">
            <summary>
            The captured result of executing a policy
            </summary>
        </member>
        <member name="P:Polly.PolicyResult.Outcome">
            <summary>
              The outcome of executing the policy
            </summary>
        </member>
        <member name="P:Polly.PolicyResult.FinalException">
            <summary>
             The final exception captured. Will be null if policy executed successfully
            </summary>
        </member>
        <member name="P:Polly.PolicyResult.ExceptionType">
            <summary>
             The exception type of the final exception captured. Will be null if policy executed successfully
            </summary>
        </member>
        <member name="T:Polly.PolicyResult`1">
            <summary>
            The captured result of executing a policy
            </summary>
        </member>
        <member name="P:Polly.PolicyResult`1.Outcome">
            <summary>
              The outcome of executing the policy
            </summary>
        </member>
        <member name="P:Polly.PolicyResult`1.FinalException">
            <summary>
             The final exception captured. Will be null if policy executed without exception.
            </summary>
        </member>
        <member name="P:Polly.PolicyResult`1.ExceptionType">
            <summary>
             The exception type of the final exception captured. Will be null if policy executed successfully
            </summary>
        </member>
        <member name="P:Polly.PolicyResult`1.Result">
            <summary>
            The result of executing the policy. Will be default(TResult) if the policy failed
            </summary>
        </member>
        <member name="P:Polly.PolicyResult`1.FinalHandledResult">
            <summary>
            The final handled result captured. Will be default(TResult) if the policy executed successfully, or terminated with an exception.
            </summary>
        </member>
        <member name="P:Polly.PolicyResult`1.FaultType">
            <summary>
             The fault type of the final fault captured. Will be null if policy executed successfully
            </summary>
        </member>
        <member name="T:Polly.OutcomeType">
            <summary>
            Represents the outcome of executing a policy
            </summary>
        </member>
        <member name="F:Polly.OutcomeType.Successful">
            <summary>
            Indicates that the policy ultimately executed successfully
            </summary>
        </member>
        <member name="F:Polly.OutcomeType.Failure">
            <summary>
            Indicates that the policy ultimately failed
            </summary>
        </member>
        <member name="T:Polly.ExceptionType">
            <summary>
            Represents the type of exception resulting from a failed policy
            </summary>
        </member>
        <member name="F:Polly.ExceptionType.HandledByThisPolicy">
            <summary>
            An exception type that has been defined to be handled by this policy
            </summary>
        </member>
        <member name="F:Polly.ExceptionType.Unhandled">
            <summary>
            An exception type that has been not been defined to be handled by this policy
            </summary>
        </member>
        <member name="T:Polly.FaultType">
            <summary>
            Represents the type of outcome from a failed policy
            </summary>
        </member>
        <member name="F:Polly.FaultType.ExceptionHandledByThisPolicy">
            <summary>
            An exception type that has been defined to be handled by this policy
            </summary>
        </member>
        <member name="F:Polly.FaultType.UnhandledException">
            <summary>
            An exception type that has been not been defined to be handled by this policy
            </summary>
        </member>
        <member name="F:Polly.FaultType.ResultHandledByThisPolicy">
            <summary>
            A result value that has been defined to be handled by this policy
            </summary>
        </member>
        <member name="T:Polly.RetrySyntax">
            <summary>
            Fluent API for defining a Retry <see cref="T:Polly.Policy"/>. 
            </summary>
        </member>
        <member name="M:Polly.RetrySyntax.Retry(Polly.PolicyBuilder)">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will retry once.
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <returns>The policy instance.</returns>
        </member>
        <member name="M:Polly.RetrySyntax.Retry(Polly.PolicyBuilder,System.Int32)">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will retry <paramref name="retryCount"/> times.
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="retryCount">The retry count.</param>
            <returns>The policy instance.</returns>
        </member>
        <member name="M:Polly.RetrySyntax.Retry(Polly.PolicyBuilder,System.Action{System.Exception,System.Int32})">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will retry once
            calling <paramref name="onRetry"/> on retry with the raised exception and retry count.
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="onRetry">The action to call on each retry.</param>
            <returns>The policy instance.</returns>
            <exception cref="T:System.ArgumentNullException">onRetry</exception>
        </member>
        <member name="M:Polly.RetrySyntax.Retry(Polly.PolicyBuilder,System.Int32,System.Action{System.Exception,System.Int32})">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will retry <paramref name="retryCount"/> times
            calling <paramref name="onRetry"/> on each retry with the raised exception and retry count.
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="retryCount">The retry count.</param>
            <param name="onRetry">The action to call on each retry.</param>
            <returns>The policy instance.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">retryCount;Value must be greater than or equal to zero.</exception>
            <exception cref="T:System.ArgumentNullException">onRetry</exception>
        </member>
        <member name="M:Polly.RetrySyntax.Retry(Polly.PolicyBuilder,System.Action{System.Exception,System.Int32,Polly.Context})">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will retry once
            calling <paramref name="onRetry"/> on retry with the raised exception, retry count and context data.
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="onRetry">The action to call on each retry.</param>
            <returns>The policy instance.</returns>
            <exception cref="T:System.ArgumentNullException">onRetry</exception>
        </member>
        <member name="M:Polly.RetrySyntax.Retry(Polly.PolicyBuilder,System.Int32,System.Action{System.Exception,System.Int32,Polly.Context})">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will retry <paramref name="retryCount"/> times
            calling <paramref name="onRetry"/> on each retry with the raised exception, retry count and context data.
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="retryCount">The retry count.</param>
            <param name="onRetry">The action to call on each retry.</param>
            <returns>The policy instance.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">retryCount;Value must be greater than or equal to zero.</exception>
            <exception cref="T:System.ArgumentNullException">onRetry</exception>
        </member>
        <member name="M:Polly.RetrySyntax.RetryForever(Polly.PolicyBuilder)">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will retry indefinitely.
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <returns>The policy instance.</returns>
        </member>
        <member name="M:Polly.RetrySyntax.RetryForever(Polly.PolicyBuilder,System.Action{System.Exception})">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will retry indefinitely
            calling <paramref name="onRetry"/> on each retry with the raised exception.
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="onRetry">The action to call on each retry.</param>
            <returns>The policy instance.</returns>
            <exception cref="T:System.ArgumentNullException">onRetry</exception>
        </member>
        <member name="M:Polly.RetrySyntax.RetryForever(Polly.PolicyBuilder,System.Action{System.Exception,Polly.Context})">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will retry indefinitely
            calling <paramref name="onRetry"/> on each retry with the raised exception and context data.
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="onRetry">The action to call on each retry.</param>
            <returns>The policy instance.</returns>
            <exception cref="T:System.ArgumentNullException">onRetry</exception>
        </member>
        <member name="M:Polly.RetrySyntax.WaitAndRetry(Polly.PolicyBuilder,System.Int32,System.Func{System.Int32,System.TimeSpan})">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will wait and retry <paramref name="retryCount"/> times.
            On each retry, the duration to wait is calculated by calling <paramref name="sleepDurationProvider"/> with
            the current retry attempt allowing an exponentially increasing wait time (exponential backoff).
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="retryCount">The retry count.</param>
            <param name="sleepDurationProvider">The function that provides the duration to wait for for a particular retry attempt.</param>
            <returns>The policy instance.</returns>
        </member>
        <member name="M:Polly.RetrySyntax.WaitAndRetry(Polly.PolicyBuilder,System.Int32,System.Func{System.Int32,System.TimeSpan},System.Action{System.Exception,System.TimeSpan})">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will wait and retry <paramref name="retryCount"/> times
            calling <paramref name="onRetry"/> on each retry with the raised exception and the current sleep duration.
            On each retry, the duration to wait is calculated by calling <paramref name="sleepDurationProvider"/> with
            the current retry attempt allowing an exponentially increasing wait time (exponential backoff).
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="retryCount">The retry count.</param>
            <param name="sleepDurationProvider">The function that provides the duration to wait for for a particular retry attempt.</param>
            <param name="onRetry">The action to call on each retry.</param>
            <returns>The policy instance.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">retryCount;Value must be greater than or equal to zero.</exception>
            <exception cref="T:System.ArgumentNullException">
            sleepDurationProvider
            or
            onRetry
            </exception>
        </member>
        <member name="M:Polly.RetrySyntax.WaitAndRetry(Polly.PolicyBuilder,System.Int32,System.Func{System.Int32,System.TimeSpan},System.Action{System.Exception,System.TimeSpan,Polly.Context})">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will wait and retry <paramref name="retryCount"/> times
            calling <paramref name="onRetry"/> on each retry with the raised exception, current sleep duration and context data.
            On each retry, the duration to wait is calculated by calling <paramref name="sleepDurationProvider"/> with
            the current retry attempt allowing an exponentially increasing wait time (exponential backoff).
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="retryCount">The retry count.</param>
            <param name="sleepDurationProvider">The function that provides the duration to wait for for a particular retry attempt.</param>
            <param name="onRetry">The action to call on each retry.</param>
            <returns>The policy instance.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">retryCount;Value must be greater than or equal to zero.</exception>
            <exception cref="T:System.ArgumentNullException">
            sleepDurationProvider
            or
            onRetry
            </exception>
        </member>
        <member name="M:Polly.RetrySyntax.WaitAndRetry(Polly.PolicyBuilder,System.Int32,System.Func{System.Int32,System.TimeSpan},System.Action{System.Exception,System.TimeSpan,System.Int32,Polly.Context})">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will wait and retry <paramref name="retryCount"/> times
            calling <paramref name="onRetry"/> on each retry with the raised exception, current sleep duration, retry count, and context data.
            On each retry, the duration to wait is calculated by calling <paramref name="sleepDurationProvider"/> with
            the current retry attempt allowing an exponentially increasing wait time (exponential backoff).
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="retryCount">The retry count.</param>
            <param name="sleepDurationProvider">The function that provides the duration to wait for for a particular retry attempt.</param>
            <param name="onRetry">The action to call on each retry.</param>
            <returns>The policy instance.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">retryCount;Value must be greater than or equal to zero.</exception>
            <exception cref="T:System.ArgumentNullException">
            timeSpanProvider
            or
            onRetry
            </exception>
        </member>
        <member name="M:Polly.RetrySyntax.WaitAndRetry(Polly.PolicyBuilder,System.Collections.Generic.IEnumerable{System.TimeSpan})">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will wait and retry as many times as there are provided <paramref name="sleepDurations"/>
            On each retry, the duration to wait is the current <paramref name="sleepDurations"/> item.
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="sleepDurations">The sleep durations to wait for on each retry.</param>
            <returns>The policy instance.</returns>
        </member>
        <member name="M:Polly.RetrySyntax.WaitAndRetry(Polly.PolicyBuilder,System.Collections.Generic.IEnumerable{System.TimeSpan},System.Action{System.Exception,System.TimeSpan})">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will wait and retry as many times as there are provided <paramref name="sleepDurations"/>
            calling <paramref name="onRetry"/> on each retry with the raised exception and the current sleep duration.
            On each retry, the duration to wait is the current <paramref name="sleepDurations"/> item.
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="sleepDurations">The sleep durations to wait for on each retry.</param>
            <param name="onRetry">The action to call on each retry.</param>
            <returns>The policy instance.</returns>
            <exception cref="T:System.ArgumentNullException">
            sleepDurations
            or
            onRetry
            </exception>
        </member>
        <member name="M:Polly.RetrySyntax.WaitAndRetry(Polly.PolicyBuilder,System.Collections.Generic.IEnumerable{System.TimeSpan},System.Action{System.Exception,System.TimeSpan,Polly.Context})">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will wait and retry as many times as there are provided <paramref name="sleepDurations"/>
            calling <paramref name="onRetry"/> on each retry with the raised exception, current sleep duration and context data.
            On each retry, the duration to wait is the current <paramref name="sleepDurations"/> item.
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="sleepDurations">The sleep durations to wait for on each retry.</param>
            <param name="onRetry">The action to call on each retry.</param>
            <returns>The policy instance.</returns>
            <exception cref="T:System.ArgumentNullException">
            sleepDurations
            or
            onRetry
            </exception>
        </member>
        <member name="M:Polly.RetrySyntax.WaitAndRetry(Polly.PolicyBuilder,System.Collections.Generic.IEnumerable{System.TimeSpan},System.Action{System.Exception,System.TimeSpan,System.Int32,Polly.Context})">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will wait and retry as many times as there are provided <paramref name="sleepDurations"/>
            calling <paramref name="onRetry"/> on each retry with the raised exception, current sleep duration, retry count and context data.
            On each retry, the duration to wait is the current <paramref name="sleepDurations"/> item.
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="sleepDurations">The sleep durations to wait for on each retry.</param>
            <param name="onRetry">The action to call on each retry.</param>
            <returns>The policy instance.</returns>
            <exception cref="T:System.ArgumentNullException">
            sleepDurations
            or
            onRetry
            </exception>
        </member>
        <member name="M:Polly.RetrySyntax.WaitAndRetryForever(Polly.PolicyBuilder,System.Func{System.Int32,System.TimeSpan})">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will wait and retry indefinitely.
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="sleepDurationProvider">The function that provides the duration to wait for for a particular retry attempt.</param>
            <returns>The policy instance.</returns>
            <exception cref="T:System.ArgumentNullException">sleepDurationProvider</exception>
        </member>
        <member name="M:Polly.RetrySyntax.WaitAndRetryForever(Polly.PolicyBuilder,System.Func{System.Int32,System.TimeSpan},System.Action{System.Exception,System.TimeSpan})">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will wait and retry indefinitely
            calling <paramref name="onRetry"/> on each retry with the raised exception.
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="sleepDurationProvider"></param>
            <param name="onRetry">The action to call on each retry.</param>
            <returns>The policy instance.</returns>
            <exception cref="T:System.ArgumentNullException">sleepDurationProvider</exception>
            <exception cref="T:System.ArgumentNullException">onRetry</exception>
        </member>
        <member name="M:Polly.RetrySyntax.WaitAndRetryForever(Polly.PolicyBuilder,System.Func{System.Int32,System.TimeSpan},System.Action{System.Exception,System.TimeSpan,Polly.Context})">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will wait and retry indefinitely
            calling <paramref name="onRetry"/> on each retry with the raised exception and
            execution context.
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="sleepDurationProvider"></param>
            <param name="onRetry">The action to call on each retry.</param>
            <returns>The policy instance.</returns>
            <exception cref="T:System.ArgumentNullException">sleepDurationProvider</exception>
            <exception cref="T:System.ArgumentNullException">onRetry</exception>
        </member>
        <member name="T:Polly.RetryTResultSyntax">
            <summary>
            Fluent API for defining a Retry <see cref="T:Polly.Policy"/>. 
            </summary>
        </member>
        <member name="M:Polly.RetryTResultSyntax.Retry``1(Polly.PolicyBuilder{``0})">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will retry once.
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <returns>The policy instance.</returns>
        </member>
        <member name="M:Polly.RetryTResultSyntax.Retry``1(Polly.PolicyBuilder{``0},System.Int32)">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will retry <paramref name="retryCount"/> times.
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="retryCount">The retry count.</param>
            <returns>The policy instance.</returns>
        </member>
        <member name="M:Polly.RetryTResultSyntax.Retry``1(Polly.PolicyBuilder{``0},System.Action{Polly.DelegateResult{``0},System.Int32})">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will retry once
            calling <paramref name="onRetry"/> on retry with the handled exception or result and retry count.
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="onRetry">The action to call on each retry.</param>
            <returns>The policy instance.</returns>
            <exception cref="T:System.ArgumentNullException">onRetry</exception>
        </member>
        <member name="M:Polly.RetryTResultSyntax.Retry``1(Polly.PolicyBuilder{``0},System.Int32,System.Action{Polly.DelegateResult{``0},System.Int32})">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will retry <paramref name="retryCount"/> times
            calling <paramref name="onRetry"/> on each retry with the handled exception or result and retry count.
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="retryCount">The retry count.</param>
            <param name="onRetry">The action to call on each retry.</param>
            <returns>The policy instance.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">retryCount;Value must be greater than or equal to zero.</exception>
            <exception cref="T:System.ArgumentNullException">onRetry</exception>
        </member>
        <member name="M:Polly.RetryTResultSyntax.Retry``1(Polly.PolicyBuilder{``0},System.Action{Polly.DelegateResult{``0},System.Int32,Polly.Context})">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will retry once
            calling <paramref name="onRetry"/> on retry with the handled exception or result, retry count and context data.
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="onRetry">The action to call on each retry.</param>
            <returns>The policy instance.</returns>
            <exception cref="T:System.ArgumentNullException">onRetry</exception>
        </member>
        <member name="M:Polly.RetryTResultSyntax.Retry``1(Polly.PolicyBuilder{``0},System.Int32,System.Action{Polly.DelegateResult{``0},System.Int32,Polly.Context})">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will retry <paramref name="retryCount"/> times
            calling <paramref name="onRetry"/> on each retry with the handled exception or result, retry count and context data.
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="retryCount">The retry count.</param>
            <param name="onRetry">The action to call on each retry.</param>
            <returns>The policy instance.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">retryCount;Value must be greater than or equal to zero.</exception>
            <exception cref="T:System.ArgumentNullException">onRetry</exception>
        </member>
        <member name="M:Polly.RetryTResultSyntax.RetryForever``1(Polly.PolicyBuilder{``0})">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will retry indefinitely.
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <returns>The policy instance.</returns>
        </member>
        <member name="M:Polly.RetryTResultSyntax.RetryForever``1(Polly.PolicyBuilder{``0},System.Action{System.Exception})">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will retry indefinitely
            calling <paramref name="onRetry"/> on each retry with the handled exception or result.
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="onRetry">The action to call on each retry.</param>
            <returns>The policy instance.</returns>
            <exception cref="T:System.ArgumentNullException">onRetry</exception>
        </member>
        <member name="M:Polly.RetryTResultSyntax.RetryForever``1(Polly.PolicyBuilder{``0},System.Action{Polly.DelegateResult{``0},Polly.Context})">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will retry indefinitely
            calling <paramref name="onRetry"/> on each retry with the handled exception or result and context data.
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="onRetry">The action to call on each retry.</param>
            <returns>The policy instance.</returns>
            <exception cref="T:System.ArgumentNullException">onRetry</exception>
        </member>
        <member name="M:Polly.RetryTResultSyntax.WaitAndRetry``1(Polly.PolicyBuilder{``0},System.Int32,System.Func{System.Int32,System.TimeSpan})">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will wait and retry <paramref name="retryCount"/> times.
            On each retry, the duration to wait is calculated by calling <paramref name="sleepDurationProvider"/> with
            the current retry attempt allowing an exponentially increasing wait time (exponential backoff).
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="retryCount">The retry count.</param>
            <param name="sleepDurationProvider">The function that provides the duration to wait for for a particular retry attempt.</param>
            <returns>The policy instance.</returns>
        </member>
        <member name="M:Polly.RetryTResultSyntax.WaitAndRetry``1(Polly.PolicyBuilder{``0},System.Int32,System.Func{System.Int32,System.TimeSpan},System.Action{Polly.DelegateResult{``0},System.TimeSpan})">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will wait and retry <paramref name="retryCount"/> times
            calling <paramref name="onRetry"/> on each retry with the handled exception or result and the current sleep duration.
            On each retry, the duration to wait is calculated by calling <paramref name="sleepDurationProvider"/> with
            the current retry attempt allowing an exponentially increasing wait time (exponential backoff).
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="retryCount">The retry count.</param>
            <param name="sleepDurationProvider">The function that provides the duration to wait for for a particular retry attempt.</param>
            <param name="onRetry">The action to call on each retry.</param>
            <returns>The policy instance.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">retryCount;Value must be greater than or equal to zero.</exception>
            <exception cref="T:System.ArgumentNullException">
            sleepDurationProvider
            or
            onRetry
            </exception>
        </member>
        <member name="M:Polly.RetryTResultSyntax.WaitAndRetry``1(Polly.PolicyBuilder{``0},System.Int32,System.Func{System.Int32,System.TimeSpan},System.Action{Polly.DelegateResult{``0},System.TimeSpan,Polly.Context})">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will wait and retry <paramref name="retryCount"/> times
            calling <paramref name="onRetry"/> on each retry with the handled exception or result, current sleep duration and context data.
            On each retry, the duration to wait is calculated by calling <paramref name="sleepDurationProvider"/> with
            the current retry attempt allowing an exponentially increasing wait time (exponential backoff).
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="retryCount">The retry count.</param>
            <param name="sleepDurationProvider">The function that provides the duration to wait for for a particular retry attempt.</param>
            <param name="onRetry">The action to call on each retry.</param>
            <returns>The policy instance.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">retryCount;Value must be greater than or equal to zero.</exception>
            <exception cref="T:System.ArgumentNullException">
            sleepDurationProvider
            or
            onRetry
            </exception>
        </member>
        <member name="M:Polly.RetryTResultSyntax.WaitAndRetry``1(Polly.PolicyBuilder{``0},System.Int32,System.Func{System.Int32,System.TimeSpan},System.Action{Polly.DelegateResult{``0},System.TimeSpan,System.Int32,Polly.Context})">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will wait and retry <paramref name="retryCount"/> times
            calling <paramref name="onRetry"/> on each retry with the handled exception or result, current sleep duration, retry count, and context data.
            On each retry, the duration to wait is calculated by calling <paramref name="sleepDurationProvider"/> with
            the current retry attempt allowing an exponentially increasing wait time (exponential backoff).
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="retryCount">The retry count.</param>
            <param name="sleepDurationProvider">The function that provides the duration to wait for for a particular retry attempt.</param>
            <param name="onRetry">The action to call on each retry.</param>
            <returns>The policy instance.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">retryCount;Value must be greater than or equal to zero.</exception>
            <exception cref="T:System.ArgumentNullException">
            timeSpanProvider
            or
            onRetry
            </exception>
        </member>
        <member name="M:Polly.RetryTResultSyntax.WaitAndRetry``1(Polly.PolicyBuilder{``0},System.Collections.Generic.IEnumerable{System.TimeSpan})">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will wait and retry as many times as there are provided <paramref name="sleepDurations"/>
            On each retry, the duration to wait is the current <paramref name="sleepDurations"/> item.
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="sleepDurations">The sleep durations to wait for on each retry.</param>
            <returns>The policy instance.</returns>
        </member>
        <member name="M:Polly.RetryTResultSyntax.WaitAndRetry``1(Polly.PolicyBuilder{``0},System.Collections.Generic.IEnumerable{System.TimeSpan},System.Action{Polly.DelegateResult{``0},System.TimeSpan})">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will wait and retry as many times as there are provided <paramref name="sleepDurations"/>
            calling <paramref name="onRetry"/> on each retry with the handled exception or result and the current sleep duration.
            On each retry, the duration to wait is the current <paramref name="sleepDurations"/> item.
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="sleepDurations">The sleep durations to wait for on each retry.</param>
            <param name="onRetry">The action to call on each retry.</param>
            <returns>The policy instance.</returns>
            <exception cref="T:System.ArgumentNullException">
            sleepDurations
            or
            onRetry
            </exception>
        </member>
        <member name="M:Polly.RetryTResultSyntax.WaitAndRetry``1(Polly.PolicyBuilder{``0},System.Collections.Generic.IEnumerable{System.TimeSpan},System.Action{Polly.DelegateResult{``0},System.TimeSpan,Polly.Context})">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will wait and retry as many times as there are provided <paramref name="sleepDurations"/>
            calling <paramref name="onRetry"/> on each retry with the handled exception or result, current sleep duration and context data.
            On each retry, the duration to wait is the current <paramref name="sleepDurations"/> item.
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="sleepDurations">The sleep durations to wait for on each retry.</param>
            <param name="onRetry">The action to call on each retry.</param>
            <returns>The policy instance.</returns>
            <exception cref="T:System.ArgumentNullException">
            sleepDurations
            or
            onRetry
            </exception>
        </member>
        <member name="M:Polly.RetryTResultSyntax.WaitAndRetry``1(Polly.PolicyBuilder{``0},System.Collections.Generic.IEnumerable{System.TimeSpan},System.Action{Polly.DelegateResult{``0},System.TimeSpan,System.Int32,Polly.Context})">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will wait and retry as many times as there are provided <paramref name="sleepDurations"/>
            calling <paramref name="onRetry"/> on each retry with the handled exception or result, current sleep duration, retry count and context data.
            On each retry, the duration to wait is the current <paramref name="sleepDurations"/> item.
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="sleepDurations">The sleep durations to wait for on each retry.</param>
            <param name="onRetry">The action to call on each retry.</param>
            <returns>The policy instance.</returns>
            <exception cref="T:System.ArgumentNullException">
            sleepDurations
            or
            onRetry
            </exception>
        </member>
        <member name="M:Polly.RetryTResultSyntax.WaitAndRetryForever``1(Polly.PolicyBuilder{``0},System.Func{System.Int32,System.TimeSpan})">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will wait and retry indefinitely.
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="sleepDurationProvider">The function that provides the duration to wait for for a particular retry attempt.</param>
            <returns>The policy instance.</returns>
            <exception cref="T:System.ArgumentNullException">sleepDurationProvider</exception>
        </member>
        <member name="M:Polly.RetryTResultSyntax.WaitAndRetryForever``1(Polly.PolicyBuilder{``0},System.Func{System.Int32,System.TimeSpan},System.Action{Polly.DelegateResult{``0},System.TimeSpan})">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will wait and retry indefinitely
            calling <paramref name="onRetry"/> on each retry with the handled exception or result.
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="sleepDurationProvider"></param>
            <param name="onRetry">The action to call on each retry.</param>
            <returns>The policy instance.</returns>
            <exception cref="T:System.ArgumentNullException">sleepDurationProvider</exception>
            <exception cref="T:System.ArgumentNullException">onRetry</exception>
        </member>
        <member name="M:Polly.RetryTResultSyntax.WaitAndRetryForever``1(Polly.PolicyBuilder{``0},System.Func{System.Int32,System.TimeSpan},System.Action{Polly.DelegateResult{``0},System.TimeSpan,Polly.Context})">
            <summary>
            Builds a <see cref="T:Polly.Policy"/> that will wait and retry indefinitely
            calling <paramref name="onRetry"/> on each retry with the handled exception or result and
            execution context.
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="sleepDurationProvider"></param>
            <param name="onRetry">The action to call on each retry.</param>
            <returns>The policy instance.</returns>
            <exception cref="T:System.ArgumentNullException">sleepDurationProvider</exception>
            <exception cref="T:System.ArgumentNullException">onRetry</exception>
        </member>
        <member name="T:Polly.Retry.RetryPolicy">
            <summary>
            A retry policy that can be applied to delegates.
            </summary>
        </member>
        <member name="T:Polly.Retry.RetryPolicy`1">
            <summary>
            A retry policy that can be applied to delegates returning a value of type <typeparam name="TResult"/>.
            </summary>
        </member>
        <member name="T:Polly.AdvancedCircuitBreakerSyntax">
            <summary>
            Fluent API for defining a Circuit Breaker <see cref="T:Polly.Policy"/>. 
            </summary>
        </member>
        <member name="M:Polly.AdvancedCircuitBreakerSyntax.AdvancedCircuitBreaker(Polly.PolicyBuilder,System.Double,System.TimeSpan,System.Int32,System.TimeSpan)">
            <summary>
            <para> Builds a <see cref="T:Polly.Policy"/> that will function like a Circuit Breaker.</para>
            <para>The circuit will break if, within any timeslice of duration <paramref name="samplingDuration"/>, the proportion of actions resulting in a handled exception exceeds <paramref name="failureThreshold"/>, provided also that the number of actions through the circuit in the timeslice is at least <paramref name="minimumThroughput" />. </para>
            <para>The circuit will stay broken for the <paramref name="durationOfBreak" />. Any attempt to execute this policy
            while the circuit is broken, will immediately throw a <see cref="T:Polly.CircuitBreaker.BrokenCircuitException" /> containing the exception
            that broke the circuit.
            </para>
            <para>If the first action after the break duration period results in a handled exception, the circuit will break
            again for another <paramref name="durationOfBreak" />; if no exception is thrown, the circuit will reset.
            </para>
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="failureThreshold">The failure threshold at which the circuit will break (a number between 0 and 1; eg 0.5 represents breaking if 50% or more of actions result in a handled failure).</param>
            <param name="samplingDuration">The duration of the timeslice over which failure ratios are assessed.</param>
            <param name="minimumThroughput">The minimum throughput: this many actions or more must pass through the circuit in the timeslice, for statistics to be considered significant and the circuit-breaker to come into action.</param>
            <param name="durationOfBreak">The duration the circuit will stay open before resetting.</param>
            <returns>The policy instance.</returns>
            <remarks>(see "Release It!" by Michael T. Nygard fi)</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">failureThreshold;Value must be greater than zero</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">failureThreshold;Value must be less than or equal to one</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">samplingDuration;Value must be equal to or greater than the minimum resolution of the CircuitBreaker timer</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">minimumThroughput;Value must be greater than one</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">durationOfBreak;Value must be greater than zero</exception>
        </member>
        <member name="M:Polly.AdvancedCircuitBreakerSyntax.AdvancedCircuitBreaker(Polly.PolicyBuilder,System.Double,System.TimeSpan,System.Int32,System.TimeSpan,System.Action{System.Exception,System.TimeSpan},System.Action)">
            <summary>
            <para>The circuit will break if, within any timeslice of duration <paramref name="samplingDuration"/>, the proportion of actions resulting in a handled exception exceeds <paramref name="failureThreshold"/>, provided also that the number of actions through the circuit in the timeslice is at least <paramref name="minimumThroughput" />. </para>
            <para>The circuit will stay broken for the <paramref name="durationOfBreak" />. Any attempt to execute this policy
            while the circuit is broken, will immediately throw a <see cref="T:Polly.CircuitBreaker.BrokenCircuitException" /> containing the exception
            that broke the circuit.
            </para>
            <para>If the first action after the break duration period results in a handled exception, the circuit will break
            again for another <paramref name="durationOfBreak" />; if no exception is thrown, the circuit will reset.
            </para>
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="failureThreshold">The failure threshold at which the circuit will break (a number between 0 and 1; eg 0.5 represents breaking if 50% or more of actions result in a handled failure.</param>
            <param name="samplingDuration">The duration of the timeslice over which failure ratios are assessed.</param>
            <param name="minimumThroughput">The minimum throughput: this many actions or more must pass through the circuit in the timeslice, for statistics to be considered significant and the circuit-breaker to come into action.</param>
            <param name="durationOfBreak">The duration the circuit will stay open before resetting.</param>
            <param name="onBreak">The action to call when the circuit transitions to an <see cref="F:Polly.CircuitBreaker.CircuitState.Open"/> state.</param>
            <param name="onReset">The action to call when the circuit resets to a <see cref="F:Polly.CircuitBreaker.CircuitState.Closed"/> state.</param>
            <returns>The policy instance.</returns>
            <remarks>(see "Release It!" by Michael T. Nygard fi)</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">failureThreshold;Value must be greater than zero</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">failureThreshold;Value must be less than or equal to one</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">samplingDuration;Value must be equal to or greater than the minimum resolution of the CircuitBreaker timer</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">minimumThroughput;Value must be greater than one</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">durationOfBreak;Value must be greater than zero</exception>
            <exception cref="T:System.ArgumentNullException">onBreak</exception>
            <exception cref="T:System.ArgumentNullException">onReset</exception>
        </member>
        <member name="M:Polly.AdvancedCircuitBreakerSyntax.AdvancedCircuitBreaker(Polly.PolicyBuilder,System.Double,System.TimeSpan,System.Int32,System.TimeSpan,System.Action{System.Exception,System.TimeSpan,Polly.Context},System.Action{Polly.Context})">
            <summary>
            <para>The circuit will break if, within any timeslice of duration <paramref name="samplingDuration"/>, the proportion of actions resulting in a handled exception exceeds <paramref name="failureThreshold"/>, provided also that the number of actions through the circuit in the timeslice is at least <paramref name="minimumThroughput" />. </para>
            <para>The circuit will stay broken for the <paramref name="durationOfBreak" />. Any attempt to execute this policy
            while the circuit is broken, will immediately throw a <see cref="T:Polly.CircuitBreaker.BrokenCircuitException" /> containing the exception
            that broke the circuit.
            </para>
            <para>If the first action after the break duration period results in a handled exception, the circuit will break
            again for another <paramref name="durationOfBreak" />; if no exception is thrown, the circuit will reset.
            </para>
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="failureThreshold">The failure threshold at which the circuit will break (a number between 0 and 1; eg 0.5 represents breaking if 50% or more of actions result in a handled failure.</param>
            <param name="samplingDuration">The duration of the timeslice over which failure ratios are assessed.</param>
            <param name="minimumThroughput">The minimum throughput: this many actions or more must pass through the circuit in the timeslice, for statistics to be considered significant and the circuit-breaker to come into action.</param>
            <param name="durationOfBreak">The duration the circuit will stay open before resetting.</param>
            <param name="onBreak">The action to call when the circuit transitions to an <see cref="F:Polly.CircuitBreaker.CircuitState.Open"/> state.</param>
            <param name="onReset">The action to call when the circuit resets to a <see cref="F:Polly.CircuitBreaker.CircuitState.Closed"/> state.</param>
            <returns>The policy instance.</returns>
            <remarks>(see "Release It!" by Michael T. Nygard fi)</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">failureThreshold;Value must be greater than zero</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">failureThreshold;Value must be less than or equal to one</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">samplingDuration;Value must be equal to or greater than the minimum resolution of the CircuitBreaker timer</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">minimumThroughput;Value must be greater than one</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">durationOfBreak;Value must be greater than zero</exception>
            <exception cref="T:System.ArgumentNullException">onBreak</exception>
            <exception cref="T:System.ArgumentNullException">onReset</exception>
        </member>
        <member name="M:Polly.AdvancedCircuitBreakerSyntax.AdvancedCircuitBreaker(Polly.PolicyBuilder,System.Double,System.TimeSpan,System.Int32,System.TimeSpan,System.Action{System.Exception,System.TimeSpan},System.Action,System.Action)">
            <summary>
            <para>The circuit will break if, within any timeslice of duration <paramref name="samplingDuration"/>, the proportion of actions resulting in a handled exception exceeds <paramref name="failureThreshold"/>, provided also that the number of actions through the circuit in the timeslice is at least <paramref name="minimumThroughput" />. </para>
            <para>The circuit will stay broken for the <paramref name="durationOfBreak" />. Any attempt to execute this policy
            while the circuit is broken, will immediately throw a <see cref="T:Polly.CircuitBreaker.BrokenCircuitException" /> containing the exception
            that broke the circuit.
            </para>
            <para>If the first action after the break duration period results in a handled exception, the circuit will break
            again for another <paramref name="durationOfBreak" />; if no exception is thrown, the circuit will reset.
            </para>
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="failureThreshold">The failure threshold at which the circuit will break (a number between 0 and 1; eg 0.5 represents breaking if 50% or more of actions result in a handled failure.</param>
            <param name="samplingDuration">The duration of the timeslice over which failure ratios are assessed.</param>
            <param name="minimumThroughput">The minimum throughput: this many actions or more must pass through the circuit in the timeslice, for statistics to be considered significant and the circuit-breaker to come into action.</param>
            <param name="durationOfBreak">The duration the circuit will stay open before resetting.</param>
            <param name="onBreak">The action to call when the circuit transitions to an <see cref="F:Polly.CircuitBreaker.CircuitState.Open"/> state.</param>
            <param name="onReset">The action to call when the circuit resets to a <see cref="F:Polly.CircuitBreaker.CircuitState.Closed"/> state.</param>
            <param name="onHalfOpen">The action to call when the circuit transitions to <see cref="F:Polly.CircuitBreaker.CircuitState.HalfOpen"/> state, ready to try action executions again. </param>
            <returns>The policy instance.</returns>
            <remarks>(see "Release It!" by Michael T. Nygard fi)</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">failureThreshold;Value must be greater than zero</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">failureThreshold;Value must be less than or equal to one</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">samplingDuration;Value must be equal to or greater than the minimum resolution of the CircuitBreaker timer</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">minimumThroughput;Value must be greater than one</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">durationOfBreak;Value must be greater than zero</exception>
            <exception cref="T:System.ArgumentNullException">onBreak</exception>
            <exception cref="T:System.ArgumentNullException">onReset</exception>
            <exception cref="T:System.ArgumentNullException">onHalfOpen</exception>
        </member>
        <member name="M:Polly.AdvancedCircuitBreakerSyntax.AdvancedCircuitBreaker(Polly.PolicyBuilder,System.Double,System.TimeSpan,System.Int32,System.TimeSpan,System.Action{System.Exception,System.TimeSpan,Polly.Context},System.Action{Polly.Context},System.Action)">
            <summary>
            <para> Builds a <see cref="T:Polly.Policy" /> that will function like a Circuit Breaker.</para>
            <para>The circuit will break if, within any timeslice of duration <paramref name="samplingDuration"/>, the proportion of actions resulting in a handled exception exceeds <paramref name="failureThreshold"/>, provided also that the number of actions through the circuit in the timeslice is at least <paramref name="minimumThroughput" />. </para>
            <para>The circuit will stay broken for the <paramref name="durationOfBreak" />. Any attempt to execute this policy
            while the circuit is broken, will immediately throw a <see cref="T:Polly.CircuitBreaker.BrokenCircuitException" /> containing the exception
            that broke the circuit.
            </para>
            <para>If the first action after the break duration period results in a handled exception, the circuit will break
            again for another <paramref name="durationOfBreak" />; if no exception is thrown, the circuit will reset.
            </para>
            </summary>
            <param name="policyBuilder">The policy builder.</param>
            <param name="failureThreshold">The failure threshold at which the circuit will break (a number between 0 and 1; eg 0.5 represents breaking if 50% or more of actions result in a handled failure.</param>
            <param name="samplingDuration">The duration of the timeslice over which failure ratios are assessed.</param>
            <param name="minimumThroughput">The minimum throughput: this many actions or more must pass through the circuit in the timeslice, for statistics to be considered significant and the circuit-breaker to come into action.</param>
            <param name="durationOfBreak">The duration the circuit will stay open before resetting.</param>
            <param name="onBreak">The action to call when the circuit transitions to an <see cref="F:Polly.CircuitBreaker.CircuitState.Open" /> state.</param>
            <param name="onReset">The action to call when the circuit resets to a <see cref="F:Polly.CircuitBreaker.CircuitState.Closed" /> state.</param>
            <param name="onHalfOpen">The action to call when the circuit transitions to <see cref="F:Polly.CircuitBreaker.CircuitState.HalfOpen" /> state, ready to try action executions again.</param>
            <returns>The policy instance.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">failureThreshold;Value must be greater than zero</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">failureThreshold;Value must be less than or equal to one</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">samplingDuration;Value must be equal to or greater than the minimum resolution of the CircuitBreaker timer</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">minimumThroughput;Value must be greater than one</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">durationOfBreak;Value must be greater than zero</exception>
            <exception cref="T:System.ArgumentNullException">onBreak</exception>
            <exception cref="T:System.ArgumentNullException">onReset</exception>
            <exception cref="T:System.ArgumentNullException">onHalfOpen</exception>
            <remarks>(see "Release It!" by Michael T. Nygard fi)</remarks>
        </member>
        <member name="T:Polly.Utilities.EmptyStruct">
            <summary>
            A null struct for policies and actions which do not return a TResult.
            </summary>
        </member>
        <member name="T:Polly.Utilities.ReadOnlyDictionary`2">
            http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=29
            <summary>
            Provides the base class for a generic read-only dictionary.
            </summary>
            <typeparam name="TKey">
            The type of keys in the dictionary.
            </typeparam>
            <typeparam name="TValue">
            The type of values in the dictionary.
            </typeparam>
            <remarks>
            <para>
            An instance of the <b>ReadOnlyDictionary</b> generic class is
            always read-only. A dictionary that is read-only is simply a
            dictionary with a wrapper that prevents modifying the
            dictionary; therefore, if changes are made to the underlying
            dictionary, the read-only dictionary reflects those changes. 
            See <see cref="T:System.Collections.Generic.Dictionary`2"/> for a modifiable version of 
            this class.
            </para>
            <para>
            <b>Notes to Implementers</b> This base class is provided to 
            make it easier for implementers to create a generic read-only
            custom dictionary. Implementers are encouraged to extend this
            base class instead of creating their own. 
            </para>
            </remarks>
        </member>
        <member name="M:Polly.Utilities.ReadOnlyDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Initializes a new instance of the
            <see cref="T:ReadOnlyDictionary`2" /> class that wraps
            the supplied <paramref name="values"/>.
            </summary>
            <param name="values">The <see cref="T:IDictionary`2" />
            that will be wrapped.</param>
            <exception cref="T:System.ArgumentNullException">
            Thrown when the dictionary is null.
            </exception>
        </member>
        <member name="P:Polly.Utilities.ReadOnlyDictionary`2.Count">
            <summary>
            Gets the number of key/value pairs contained in the
            <see cref="T:ReadOnlyDictionary`2"></see>.
            </summary>
            <value>The number of key/value pairs.</value>
            <returns>The number of key/value pairs contained in the
            <see cref="T:ReadOnlyDictionary`2"></see>.</returns>
        </member>
        <member name="P:Polly.Utilities.ReadOnlyDictionary`2.Keys">
            <summary>Gets a collection containing the keys in the
            <see cref="T:ReadOnlyDictionary{TKey,TValue}"></see>.</summary>
            <value>A <see cref="T:System.Collections.Generic.Dictionary`2.KeyCollection"/> 
            containing the keys.</value>
            <returns>A
            <see cref="T:System.Collections.Generic.Dictionary`2.KeyCollection"/>
            containing the keys in the
            <see cref="T:System.Collections.Generic.Dictionary`2"></see>.
            </returns>
        </member>
        <member name="P:Polly.Utilities.ReadOnlyDictionary`2.Values">
            <summary>
            Gets a collection containing the values of the
            <see cref="T:ReadOnlyDictionary`2"/>.
            </summary>
            <value>The collection of values.</value>
        </member>
        <member name="P:Polly.Utilities.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#IsReadOnly">
            <summary>Gets a value indicating whether the dictionary is read-only.
            This value will always be true.</summary>
        </member>
        <member name="P:Polly.Utilities.ReadOnlyDictionary`2.System#Collections#ICollection#IsSynchronized">
            <summary>
            Gets a value indicating whether access to the dictionary
            is synchronized (thread safe).
            </summary>
        </member>
        <member name="P:Polly.Utilities.ReadOnlyDictionary`2.System#Collections#ICollection#SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to dictionary.
            </summary>
        </member>
        <member name="P:Polly.Utilities.ReadOnlyDictionary`2.Item(`0)">
            <summary>
            Gets or sets the value associated with the specified key.
            </summary>
            <returns>
            The value associated with the specified key. If the specified key
            is not found, a get operation throws a 
            <see cref="T:System.Collections.Generic.KeyNotFoundException" />,
            and a set operation creates a new element with the specified key.
            </returns>
            <param name="key">The key of the value to get or set.</param>
            <exception cref="T:System.ArgumentNullException">
            Thrown when the key is null.
            </exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">
            The property is retrieved and key does not exist in the collection.
            </exception>
        </member>
        <member name="M:Polly.Utilities.ReadOnlyDictionary`2.System#Collections#Generic#IDictionary{TKey,TValue}#Add(`0,`1)">
            <summary>This method is not supported by the 
            <see cref="T:ReadOnlyDictionary`2"/>.</summary>
            <param name="key">
            The object to use as the key of the element to add.</param>
            <param name="value">
            The object to use as the value of the element to add.</param>
        </member>
        <member name="M:Polly.Utilities.ReadOnlyDictionary`2.ContainsKey(`0)">
            <summary>Determines whether the <see cref="T:ReadOnlyDictionary`2" />
            contains the specified key.</summary>
            <returns>
            True if the <see cref="T:ReadOnlyDictionary`2" /> contains
            an element with the specified key; otherwise, false.
            </returns>
            <param name="key">The key to locate in the
            <see cref="T:ReadOnlyDictionary`2"></see>.</param>
            <exception cref="T:System.ArgumentNullException">
            Thrown when the key is null.
            </exception>
        </member>
        <member name="M:Polly.Utilities.ReadOnlyDictionary`2.System#Collections#Generic#IDictionary{TKey,TValue}#Remove(`0)">
            <summary>
            This method is not supported by the <see cref="T:ReadOnlyDictionary`2"/>.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <returns>
            True if the element is successfully removed; otherwise, false.
            </returns>
        </member>
        <member name="M:Polly.Utilities.ReadOnlyDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Gets the value associated with the specified key.
            </summary>
            <param name="key">The key of the value to get.</param>
            <param name="value">When this method returns, contains the value
            associated with the specified key, if the key is found;
            otherwise, the default value for the type of the value parameter.
            This parameter is passed uninitialized.</param>
            <returns>
            <b>true</b> if the <see cref="T:ReadOnlyDictionary`2" /> contains
            an element with the specified key; otherwise, <b>false</b>.
            </returns>
        </member>
        <member name="M:Polly.Utilities.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>This method is not supported by the
            <see cref="T:ReadOnlyDictionary`2"/>.</summary>
            <param name="item">
            The object to add to the <see cref="T:ICollection`1"/>.
            </param>
        </member>
        <member name="M:Polly.Utilities.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Clear">
            <summary>This method is not supported by the 
            <see cref="T:ReadOnlyDictionary`2"/>.</summary>
        </member>
        <member name="M:Polly.Utilities.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Determines whether the <see cref="T:ICollection`1"/> contains a
            specific value.
            </summary>
            <param name="item">
            The object to locate in the <see cref="T:ICollection`1"/>.
            </param>
            <returns>
            <b>true</b> if item is found in the <b>ICollection</b>; 
            otherwise, <b>false</b>.
            </returns>
        </member>
        <member name="M:Polly.Utilities.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copies the elements of the ICollection to an Array, starting at a
            particular Array index. 
            </summary>
            <param name="array">The one-dimensional Array that is the
            destination of the elements copied from ICollection.
            The Array must have zero-based indexing.
            </param>
            <param name="arrayIndex">
            The zero-based index in array at which copying begins.
            </param>
        </member>
        <member name="M:Polly.Utilities.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>This method is not supported by the
            <see cref="T:ReadOnlyDictionary`2"/>.</summary>
            <param name="item">
            The object to remove from the ICollection.
            </param>
            <returns>Will never return a value.</returns>
        </member>
        <member name="M:Polly.Utilities.ReadOnlyDictionary`2.System#Collections#Generic#IEnumerable{System#Collections#Generic#KeyValuePair{TKey,TValue}}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A IEnumerator that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Polly.Utilities.ReadOnlyDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An IEnumerator that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Polly.Utilities.ReadOnlyDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            For a description of this member, see <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)"/>. 
            </summary>
            <param name="array">
            The one-dimensional Array that is the destination of the elements copied from 
            ICollection. The Array must have zero-based indexing.
            </param>
            <param name="index">
            The zero-based index in Array at which copying begins.
            </param>
        </member>
        <member name="T:Polly.Utilities.SystemClock">
            <summary>
            Time related delegates used to improve testability of the code
            </summary>
        </member>
        <member name="F:Polly.Utilities.SystemClock.Sleep">
            <summary>
            Allows the setting of a custom Thread.Sleep implementation for testing.
            By default this will be a call to <see cref="M:Thread.Sleep"/>
            </summary>
        </member>
        <member name="F:Polly.Utilities.SystemClock.UtcNow">
            <summary>
            Allows the setting of a custom DateTime.UtcNow implementation for testing.
            By default this will be a call to <see cref="P:System.DateTime.UtcNow"/>
            </summary>
        </member>
        <member name="M:Polly.Utilities.SystemClock.Reset">
            <summary>
            Resets the custom implementations to their defaults. 
            Should be called during test teardowns.
            </summary>
        </member>
    </members>
</doc>
